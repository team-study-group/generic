# Generic

## 📌 학습 내용 요약
***
*1/5*
- 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
  - 인스턴스 안에 데이터 타입
  - List<String> list = new ArrayList<>();
    - ArrayList<E> extends AbstractList<E>
    - Object 로 처리하다가 리턴 할 때는 (E) 로 형변환 처리 함
    - 값을 넣을 때는
      - add(E e) { 
          // array 한칸 늘려서 array copy 후
        Object[] elementData[index] = e;
      } 이런 느낌
***
*2/5*
- 우리는 왜 제네릭을 사용하는가 / 제네릭은 가장 늦게 도입된 새로운 기능 / 새로 도입하기까지 심사숙고 했을 것이다
- 그 어려움이 무엇이었을까
  - 중복코드가 존재 / 매커니즘을 똑같이 가지고 있는 경우
  - 모든 것을 받을 수 있는 공통의 조상인 Object 를 이용
  - 많은 시간이 지난 후 엉뚱한 값을 넣는 경우, 그럼에도 불구하고 오류가 발생하지 않으며, 실행해도 문제가 없다.
  - 문법적으로는 문제가 없지만, 코드가 설계된 목적에 부합하지 않는 경우가 올 수 있다.
  - 컴파일/런타임 때 검출되지 않는 문제가 발생한다.
  - String 을 pojo class 로 형변환 해도 컴파일 타임에 오류가 검출되지 않는다 (런타임 때 발생, ClassCastException (runtimeexception))
    - 타입이 안전하지 않다.
***
*3/5*
- 데이터 타입을 확정시키고 싶지 않을 때 와일드카드를 지정한다.
- 와일드 카드는 네이밍 규칙이 있다.
- 복수 일 떄
- 레퍼런스 타입만 사용 할 수 있다.
- 원시(기본 데이터)타입은 사용 할 수 없다.
- 래퍼클래스를 사용 할 것 (기본 데이터 타입을 객체로 포장)
 
***
*4/5*
- 제네릭 생략 (자바의 추론 가능)
- 제네릭 클래스 외에 제네릭 메서드 설명
- 접근제어자와 리턴 사이의 꺽쇠 -> U 라는 클래스와 헷갈리지 않도록 제네릭 메서드임을 선언, 그 U 라는 값의 범위 설정 (extends, super 가능)
- 메서드 시그니처? 메서드명 앞에 제네릭 타입 매개변수를 넣을 것
  - 하지만 생략 가능 (추론이 가능하기 때문)
***
*5/5*
- 제네릭 제한
- 클래스만 예시를 들었으나, 메서드도 제한 가능
- T extends Info
  - extends 는 상속뿐이 아닌, implements 인 경우도 마찬가지로 같은 방법으로 제한 가능 
  - T extends Info 일 때 Info 가 가지고 있는 것만 사용 가능


## 💡 느낀 점
- 문제 발생 > 해결 방향으로 보니까 제네릭에 대한 이해도가 더 높아지는 느낌
- implement 일 때도 T extends info 로 잡는 다는 것은 생각하지 못했음
- 하지만 너무 오래된 영상이다보니.. (11년 전)
- 그리고 복잡하게 사용하는 부분에 대해서는 따로 공부해야 할 듯

## ❓ 궁금한 점
- 2/5 에 공통의 조상을 사용할 때 Object 가 아닌 상속을 이용하면 되는것 아닌가?
  - 상속만으로는 제네릭이 제공하는 타입 안정성, 코드 가독성을 대체할 수 없다
    - 컴파일 시점에 타입 안정성 문제를 해결하기 위함
    - 타입소거 : 하위 호환성을 유지하기 위해, 제네릭을 런타임에는 알 수 없도록 컴파일 시점에 Object로 대체
      - new T() 불가
      - 원시타입 불가
      - instanceOf 사용 불가
    - 상속으로 처리할 경우 특정위치에 정확한 자식 클래스를 지정하고 싶을 때 결국 형변환이 필요
      - 제네릭으로는 타입을 컴파일타임에 정하기 때문에 이런일이 없다
- 3/5 원시타입과 래퍼타입은 어떤 차이가 있기에 제네릭에 사용이 불가능 할까
  - 원시타입
    - 스택 영역에 실제 데이터 저장
    - 성능(속도) 빠름
    - null 불가
    - 메서드 없음
    - 제네릭 사용 불가 (List, Map 사용 불가)
  - 래퍼타입
    - 힙 영역에 실제 데이터 저장
    - 성능(속도) 느림(상대적으로)
    - null 가능
    - 메서드 있음
    - 제네릭 사용 가능 (List, Map 사용 가능)
    - 오토박싱, 언박싱 자동 변환 가능 (java 5 이후)
  - 이유
    - 제네릭은 컴파일 시점에 타입을 체크하고, 런타임에는 타입 정보를 지우는 타입 소거 방식을 사용하는데,
      이 과정에서 제네릭 타입 파라미터는 최상위 타입인 Object로 대체됨
      원시타입은 Object를 상속하지 않아 Object 변환이 불가능
- 3/5 Integer id = new Integer(1); 을 왜 했을 까
  - 1. Integer id = new Integer(1);
  - 2. Integer id = 1 과의 차이는?
  - 3. 직접 1을 사용할 때와의 차이는?
    - 1: 새로운 객체를 항상 생성 - 비효율, 사용하지 말 것
    - 2. 내부적으로 Integer.valueOf(1) 이 호출 되며, 캐싱 범위 내 값은 기존 객체 재사용 함 (-128~127 캐싱되어있음)
    - 3. 2번과 동일하게 내부적으로 Integer.valueOf(1) 이 호출

## 🔗 참고 링크
- 
