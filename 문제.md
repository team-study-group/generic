문제 설명:
다음 main 메서드가 정상적으로 컴파일되고 실행되도록 Pair 클래스를 제네릭으로 작성하세요. 
Pair는 두 개의 서로 다른 타입의 데이터를 저장할 수 있어야 합니다.
또한, getMinValue()와 getMaxValue() 메서드는 두 데이터가 모두 Comparable 인터페이스를 구현하는 경우에만 사용 가능하도록 타입 제약을 걸어야 합니다.


// main 메서드 (수정 불가)
public class Problem1 {
    public static void main(String[] args) {
        // String과 Integer 쌍
        Pair<String, Integer> stringIntPair = new Pair<>("Hello", 123);
        System.out.println("String-Integer Pair: (" + stringIntPair.getFirst() + ", " + stringIntPair.getSecond() + ")");

        // Integer와 Integer 쌍 (Comparable 가능)
        Pair<Integer, Integer> intPair = new Pair<>(50, 30);
        System.out.println("Integer Pair: (" + intPair.getFirst() + ", " + intPair.getSecond() + ")");
        System.out.println("Min Value: " + intPair.getMinValue());
        System.out.println("Max Value: " + intPair.getMaxValue());

        // Double과 Double 쌍 (Comparable 가능)
        Pair<Double, Double> doublePair = new Pair<>(3.14, 2.71);
        System.out.println("Double Pair: (" + doublePair.getFirst() + ", " + doublePair.getSecond() + ")");
        System.out.println("Min Value: " + doublePair.getMinValue());
        System.println("Max Value: " + doublePair.getMaxValue());

        // String과 String 쌍 (Comparable 가능)
        Pair<String, String> stringPair = new Pair<>("banana", "apple");
        System.out.println("String Pair: (" + stringPair.getFirst() + ", " + stringPair.getSecond() + ")");
        System.out.println("Min Value: " + stringPair.getMinValue());
        System.out.println("Max Value: " + stringPair.getMaxValue());

        // String과 Integer 쌍에서 getMinValue/getMaxValue 호출 시 컴파일 에러 발생 확인 (테스트 코드)
        // Pair<String, Integer> compileErrorPair = new Pair<>("test", 1);
        // compileErrorPair.getMinValue(); // 컴파일 에러 발생해야 함
    }
}



// 두 개의 서로 다른 타입 T1, T2를 저장하는 제네릭 클래스
class Pair<T1, T2> {
    private T1 first;
    private T2 second;

    public Pair(T1 first, T2 second) {
        this.first = first;
        this.second = second;
    }

    public T1 getFirst() {
        return first;
    }

    public T2 getSecond() {
        return second;
    }

    public <T extends Comparable<T>> T getMinValue() {
        if (first instanceof Comparable && second instanceof Comparable) {
             T val1 = (T) first;
             T val2 = (T) second;
             return val1.compareTo(val2) <= 0 ? val1 : val2;
        }
    }


    public <T extends Comparable<T>> T getMaxValue() {
        if (first instanceof Comparable && second instanceof Comparable) {
             T val1 = (T) first;
             T val2 = (T) second;
             return val1.compareTo(val2) >= 0 ? val1 : val2;
        }
    }
}
















문제 2: 와일드카드와 PECS 원칙 활용
문제 설명:
다음 main 메서드가 정상적으로 컴파일되고 실행되도록 ListProcessor 클래스를 작성하세요. ListProcessor는 두 가지 정적 제네릭 메서드를 포함합니다:

copyList(List<? extends T> source, List<? super T> destination): source 리스트의 모든 요소를 destination 리스트로 복사합니다. 
이 메서드는 PECS (Producer Extends, Consumer Super) 원칙을 활용하여 유연성을 극대화해야 합니다.
printAll(List<?> list): 리스트의 모든 요소를 단순히 출력합니다.


import java.util.ArrayList;
import java.util.List;

// main 메서드 (수정 불가)
public class Problem2 {
    public static void main(String[] args) {
        List<Integer> integers = new ArrayList<>();
        integers.add(1);
        integers.add(2);

        List<Double> doubles = new ArrayList<>();
        doubles.add(3.14);
        doubles.add(2.71);

        List<Number> numbers = new ArrayList<>(); // Integer, Double의 부모
        List<Object> objects = new ArrayList<>();   // 모든 것의 부모

        // copyList 테스트
        System.out.println("--- Copying Integers to Numbers ---");
        ListProcessor.copyList(integers, numbers); // Integer -> Number (Extends, Super)
        ListProcessor.printAll(numbers); // 1, 2 출력

        System.out.println("--- Copying Doubles to Objects ---");
        ListProcessor.copyList(doubles, objects); // Double -> Object (Extends, Super)
        ListProcessor.printAll(objects); // 3.14, 2.71 출력

        System.out.println("--- Copying Numbers to Objects ---");
        ListProcessor.copyList(numbers, objects); // Number -> Object (Extends, Super)
        ListProcessor.printAll(objects); // 1, 2, 3.14, 2.71 출력 (기존 내용 유지)

        // printAll 테스트
        System.out.println("--- Printing various lists ---");
        ListProcessor.printAll(integers); // 1, 2 출력
        ListProcessor.printAll(doubles);  // 3.14, 2.71 출력
        ListProcessor.printAll(numbers);  // 1, 2 출력 (이전 내용 유지)
        ListProcessor.printAll(objects);  // 1, 2, 3.14, 2.71 출력 (이전 내용 유지)

        // 컴파일 에러가 나야 하는 경우 (테스트 코드)
        // ListProcessor.copyList(numbers, integers); // 컴파일 에러: Number를 Integer 리스트에 넣을 수 없음
        // ListProcessor.copyList(objects, doubles);  // 컴파일 에러: Object를 Double 리스트에 넣을 수 없음
    }
}





















import java.util.List;

class ListProcessor {

   ublic static <T> void copyList(List<? extends T> source, List<? super T> destination) {
        for (T item : source) { // source에서 T 타입 또는 T의 자식 타입을 안전하게 읽어올 수 있음
            destination.add(item); // destination에 T 타입 또는 T의 자식 타입을 안전하게 추가할 수 있음
        }
    }

    public static void printAll(List<?> list) {
        for (Object item : list) { // 어떤 타입이든 Object로 읽을 수 있음
            System.out.println(item);
        }
    }
}












문제 3: 제네릭 메서드와 다중 타입 제약 (Intersection Type)
문제 설명:
다음 main 메서드가 정상적으로 컴파일되고 실행되도록 Util 클래스를 작성하세요. 
Util 클래스는 printInfo라는 정적 제네릭 메서드를 포함합니다. 이 메서드는 다음과 같은 제약을 가집니다:

매개변수 T는 Runnable 인터페이스를 구현해야 합니다.
매개변수 T는 Cloneable 인터페이스를 구현해야 합니다.
매개변수 T는 Serializable 인터페이스를 구현해야 합니다.
메서드 내에서 T 타입의 객체를 run() 메서드를 호출하고, "객체 복사 성공!" 메시지를 출력해야 합니다 (실제 복사 로직은 생략해도 무방하며, clone() 메서드가 있다는 가정하에 출력).


import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

// main 메서드 (수정 불가)
public class Problem3 {
    public static void main(String[] args) {
        MyRunnableCloneableSerializable obj1 = new MyRunnableCloneableSerializable("Task 1");
        Util.printInfo(obj1);

        System.out.println("---");

        MyRunnableCloneableSerializable obj2 = new MyRunnableCloneableSerializable("Task 2");
        Util.printInfo(obj2);

        // 컴파일 에러가 나야 하는 경우 (테스트 코드)
        // class SimpleRunnable implements Runnable { public void run() { System.out.println("Simple"); } }
        // Util.printInfo(new SimpleRunnable()); // 컴파일 에러: Cloneable, Serializable 미구현
    }
}

// 다음 클래스는 수정하지 마세요. (문제의 제약을 충족하는 예시 클래스)
class MyRunnableCloneableSerializable implements Runnable, Cloneable, Serializable {
    private String name;

    public MyRunnableCloneableSerializable(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(name + " is running.");
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    @Override
    public String toString() {
        return "MyRunnableCloneableSerializable{" + "name='" + name + '\'' + '}';
    }
}
















import java.io.Serializable; // Serializable 인터페이스 import
import java.util.ArrayList; // List 사용 시 필요
import java.util.List; // List 사용 시 필요

class Util {
    // 다중 타입 제약 (Intersection Type) 활용:
    // T는 Runnable, Cloneable, Serializable 인터페이스를 모두 구현해야 함.
    public static <T extends Runnable & Cloneable & Serializable> void printInfo(T obj) {
        System.out.println("Object Info: " + obj.toString());

        // Runnable 인터페이스의 run() 메서드 호출
        System.out.println("Running task...");
        obj.run();

        // Cloneable 인터페이스를 구현하므로 clone() 메서드 호출 가능 (실제 복사 로직은 생략)
        // 실제로 obj.clone()을 호출하려면 CloneNotSupportedException 처리 필요
        System.out.println("Attempting to clone object...");
        try {
            // obj.clone(); // 실제 호출 시 CloneNotSupportedException 발생 가능성 있음
            System.out.println("객체 복사 성공!");
        } catch (Exception e) {
            System.out.println("객체 복사 실패 또는 오류 발생: " + e.getMessage());
        }
    }
}
















문제 4: 제네릭 클래스 상속과 타입 변환 (Downcasting with Generics)
문제 설명:
다음 main 메서드가 정상적으로 컴파일되고 실행되도록 Box 클래스와 GiftBox 클래스를 작성하세요.

Box 클래스는 제네릭 타입 T를 받아 하나의 아이템을 저장하는 컨테이너입니다.
GiftBox 클래스는 Box 클래스를 상속받으며, Item 타입을 제네릭으로 받습니다.
GiftBox는 unwrap()이라는 메서드를 가지며, 이 메서드는 GiftBox가 담고 있는 아이템을 Item 타입으로 반환합니다. Box의 getItem()은 T 타입으로 반환하므로, unwrap()에서 안전한 다운캐스팅이 필요할 수 있습니다.
Java

// main 메서드 (수정 불가)
public class Problem4 {
    public static void main(String[] args) {
        // Box<String> 생성
        Box<String> stringBox = new Box<>("Hello World");
        String content = stringBox.getItem();
        System.out.println("Box content: " + content);

        // GiftBox<Integer> 생성
        GiftBox<Integer> integerGiftBox = new GiftBox<>(12345);
        Integer giftContent = integerGiftBox.getItem(); // Box의 getItem 사용
        System.out.println("GiftBox getItem: " + giftContent);
        Integer unwrappedContent = integerGiftBox.unwrap(); // GiftBox의 unwrap 사용
        System.out.println("GiftBox unwrapped: " + unwrappedContent);

        // GiftBox<Double> 생성
        GiftBox<Double> doubleGiftBox = new GiftBox<>(987.65);
        Double unwrappedDouble = doubleGiftBox.unwrap();
        System.out.println("GiftBox unwrapped double: " + unwrappedDouble);

        // 컴파일 에러 발생 여부 확인 (테스트 코드)
        // GiftBox<Number> numberGiftBox = new GiftBox<>(100);
        // String test = numberGiftBox.unwrap(); // 컴파일 에러: Number를 String으로 변환 불가
    }
}

















// Box 클래스: 하나의 제네릭 아이템을 저장
class Box<T> {
    private T item;

    public Box(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

// GiftBox 클래스: Box를 상속받으며, 자체적인 제네릭 타입 Item을 가집니다.
// GiftBox<Item>은 Box<Item>의 서브타입입니다.
class GiftBox<Item> extends Box<Item> { // 여기서 Item은 Box의 T 역할을 합니다.

    public GiftBox(Item item) {
        super(item); // 부모 클래스인 Box의 생성자 호출
    }

    // unwrap 메서드는 Item 타입으로 아이템을 반환합니다.
    // getItem()은 이미 Box에서 T (여기서는 Item) 타입을 반환하므로
    // 명시적인 다운캐스팅이 필요 없어 안전합니다.
    public Item unwrap() {
        return getItem(); // Box의 getItem() 메서드를 호출하여 Item 타입을 반환
                          // 컴파일러가 타입 안정성을 보장합니다.
    }
}















문제 5: 제네릭 인터페이스 구현 및 Comparator 활용
문제 설명:
다음 main 메서드가 정상적으로 컴파일되고 실행되도록 Sorter 인터페이스와 이를 구현하는 BubbleSorter 클래스를 작성하세요.

Sorter 인터페이스는 제네릭 타입 T를 받으며, sort(List<T> list) 메서드를 정의합니다.
BubbleSorter 클래스는 Sorter 인터페이스를 구현하며, 버블 정렬 알고리즘을 사용합니다.
BubbleSorter는 생성자를 통해 Comparator<T>를 받아서 정렬에 활용해야 합니다. 즉, T는 Comparable을 직접 구현하지 않아도 Comparator를 통해 비교할 수 있어야 합니다.
Java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

// main 메서드 (수정 불가)
public class Problem5 {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9, 4));
        System.out.println("Original Numbers: " + numbers);
        Sorter<Integer> intSorter = new BubbleSorter<>(Comparator.naturalOrder()); // 오름차순 정렬
        intSorter.sort(numbers);
        System.out.println("Sorted Numbers (Asc): " + numbers); // 1, 2, 4, 5, 8, 9

        List<String> names = new ArrayList<>(Arrays.asList("banana", "apple", "grape", "cherry"));
        System.out.println("Original Names: " + names);
        Sorter<String> stringSorter = new BubbleSorter<>(Comparator.reverseOrder()); // 내림차순 정렬
        stringSorter.sort(names);
        System.out.println("Sorted Names (Desc): " + names); // grape, cherry, banana, apple

        // 커스텀 객체 정렬 (Comparable을 구현하지 않아도 Comparator로 정렬 가능)
        class Person {
            String name;
            int age;

            public Person(String name, int age) {
                this.name = name;
                this.age = age;
            }

            @Override
            public String toString() {
                return name + "(" + age + ")";
            }
        }

        List<Person> people = new ArrayList<>(Arrays.asList(
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Charlie", 35)
        ));
        System.out.println("Original People: " + people);

        // 나이 기준 오름차순 정렬
        Sorter<Person> personAgeSorter = new BubbleSorter<>(Comparator.comparingInt(p -> p.age));
        personAgeSorter.sort(people);
        System.out.println("Sorted People by Age (Asc): " + people); // Bob(25), Alice(30), Charlie(35)

        // 이름 기준 내림차순 정렬
        Sorter<Person> personNameSorter = new BubbleSorter<>(Comparator.comparing(p -> p.name, Comparator.reverseOrder()));
        personNameSorter.sort(people);
        System.out.println("Sorted People by Name (Desc): " + people); // Charlie(35), Bob(25), Alice(30)
    }
}





















import java.util.Comparator;
import java.util.List;

// 제네릭 Sorter 인터페이스 정의
interface Sorter<T> {
    void sort(List<T> list);
}

// BubbleSorter 클래스: Sorter 인터페이스 구현
class BubbleSorter<T> implements Sorter<T> {
    private Comparator<T> comparator; // 정렬에 사용할 Comparator

    // 생성자를 통해 Comparator를 주입받습니다.
    public BubbleSorter(Comparator<T> comparator) {
        this.comparator = comparator;
    }

    @Override
    public void sort(List<T> list) {
        if (list == null || list.size() <= 1) {
            return; // 리스트가 비어있거나 요소가 하나면 정렬할 필요 없음
        }

        int n = list.size();
        boolean swapped;
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            for (int j = 0; j < n - 1 - i; j++) {
                // Comparator를 사용하여 두 요소를 비교합니다.
                // comparator.compare(obj1, obj2)는 obj1이 obj2보다 작으면 음수, 같으면 0, 크면 양수를 반환합니다.
                if (comparator.compare(list.get(j), list.get(j + 1)) > 0) {
                    // 순서가 바뀌어야 한다면 스왑
                    T temp = list.get(j);
                    list.set(j, list.get(j + 1));
                    list.set(j + 1, temp);
                    swapped = true;
                }
            }
            // 한 패스에서 스왑이 없었다면 이미 정렬된 상태
            if (!swapped) {
                break;
            }
        }
    }
}
